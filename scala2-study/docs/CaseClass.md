# CASE CLASS

`Case class` is like a regular class with a few key additions. Those details are added compiler sees the case keyword in front of a class.


## Defining a case class
```
case class Person(name:String, age:Int) 
```

## Creating an object from case class 
```
val person = Person("Snape", 40)
```
Here, keyword `new` is not required while instantiating and this is because case classes have an apply method by default which takes care of object construction. 

But you can still create an object using new keyword. 

```
val newPerson = new Person("Snape", 40)
```

`Case class` is scale way to allow pattern matching on an object without requiring a large amount of boilerplate.


## Features 

Case class are created with additional features. 

### Companion Object 

Case class has an companion object which contains factory method (`apply`) to create objects and extractor method (`unapply`) used for pattern matching.

### Already defined methods

#### Accessor and Mutator Methods 

When declaring a case class like

```
case class Person(name:String, age:Int) 
```

parameters *name* and *age* are `public` and `val` and its `accessor` method is implicitly generated.
`mutator` method is not generated by case class , unless parameter is of var.

We can declare a parameter with `val` as below
```
case class Person(name:String, var age:Int) 
```
`accessor` method is implicitly generated for both name and age.
`mutator` method is generated only for *age* 


#### Comparison and Hashcode 

Case classes also have automatically-generated equals and hashCode methods. 

```
val person1 = Person("Lilly", 21)
val person2 = Person("Lilly", 21) 
```
**`Comparison`**
```
val areSamePerson = person1 == person2  // true
```

**`hashCode`**
```
println(person2.#)
println(person2.hashCode)
```

Instances of case classes are compared by structure and not by reference.

Even though person1 and person2 refer to different objects, the value of each object is equal.

#### shallow copy method

You can create a (shallow) copy of an instance of a case class simply by using the copy method. You can optionally change the constructor arguments.

```
val person3 = Person("Dolores", 21)
val person4 = person3.copy(age = 31)
val person5 = person3.copy()


```

#### toString method
Case classes also have a good default toString method implementation, which at the very least is helpful when debugging code:
```
val person6 = Person("Ron", 17)

println(person6) // implicitly called toString
println(person6.toString)
```


#### apply Method
As it is mentioned before too, when you define a class as a case class, you don’t have to use the new keyword to create a new instance. 


```
// no need of new keyword
val person7 = Person("Harry", 17)

// explicitly creating using apply method
val person8 = Person.apply("Harry", 17)

```

#### Unapply Method 

Unapply method in a case class is a part of its companion object.

We can call unapply method like :
```
Person.unapply(Person("Harry", 17))// Some((Harry,17)): Option[(String, Int)]
```
`unapply` is used in pattern matching.
It called an extractor method. 
We can extract the values of parameters out of it using this way :
```
val person9 = Person("Leona", 15)
val Person(name, age) = person9 

println(s"Extracted ${name} and ${age} from ${person9}")

```
In `val Person(name, age) = person9 ` unapply is implicitly called and pattern match is happening here.


`unapply` is also called implicitly when pattern matching  
```
def getPrintableString(p: Person): String = p match {
    case Person("Harry", age) =>
        s"Harry is the chosen one and is $age years old."
    case Person(name, _) =>
        s"$name is not the chosen one."
}

getPrintableString(person9) // Leona is not the chosen one.​
```

### Cannot extend a case class 
Case class cannot extend another case class.

**This wont work :**
```
class Wizard(name:String , age:Int) extends Person(name, age)
```


### Instance of Product class 

Case classes mix in the [scala.Product](https://www.scala-lang.org/api/current/scala/Product.html) trait, which provides a few generic methods for working with the fields of type and case-class instances

Thus inherit these methods:
```
def productElement(n: Int): Any
def productArity: Int
def productIterator: Iterator[Any]
```
* **productArity** returns the number of class parameters, 
* **productElement(i)** returns the ith parameter
* **productIterator** allows iterating through them.

### Serializable by default

Case class also extends `Serializable` trait. 

`Serializable` trait is extended so that case class can be treated as a pure data - i.e capable of being serialized.

This way we can serialize and deserialize the objects of case class. 

*Serializing* an object means taking the data stored in an object and converting it to bytes (or a string). 

*Deserializing* an object means reading data from a string / file to create a Scala object.
